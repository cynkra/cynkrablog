{
  "hash": "d88d72b4b42b14be11c26b7ac8492d25",
  "result": {
    "engine": "knitr",
    "markdown": "---\nlayout: post\ntitle: \"Introducing blockr: a no-code dashboard builder for R\"\nimage: logo.png\nauthor: David Granjon\ndate: '2024-09-16'\ncategories:\n  - R\nformat: \n  html:\n    code-fold: 'show'\nfilters:\n  - shinylive\n---\n\n\n\n![](https://avatars.githubusercontent.com/u/145758851?s=400&u=1545a34095e8e84f5cb2b292b1e900df59ba7239&v=4){width=25% fig-align=\"center\"}\n\nSince 2023, [BristolMyersSquibb](https://www.bms.com/), the Y [company](https://the-y-company.com/) and [cynkra](cynkra.com) have teamed up to develop a novel __no-code__ solution for R.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(blockr)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'blockr'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:graphics':\n\n    layout\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(pracma)\n```\n:::\n\n\n\n## Introduction\n\nblockr is an R package designed to democratize __data analysis__ by providing a __flexible__, __intuitive__, and __code-free__ approach to building data pipelines. It has 2 main user targets:\n\n1. On the one hand, it empowers __non technical__ users to create insightful data workflows using __pre-built__ blocks that can be easily connected, all without writing a single line of code.\n2. On the other hand, it provides developers with a set of tools to seamlessly create new blocks, thereby enhancing the entire framework and fostering __collaboration__ within organizations teams.\n\nblockr is data __agnostic__, meaning it can work with any kind of dataset, that is pharmaceutical data or sport analytics data. It builds on top of [shiny](https://shiny.posit.co/) to ensure real time feedback to any data change. Finally, it allows to export code to create __reproducible__ data analysis.\n\n\n## Getting started\n\n### As a simple user\n\nAs a simple user, you're not expected to write any single line of code to use blockr. You can use the below kitchen sink to get started. This example is based on the palmer penguins data and running a single stack with 3 blocks: the first block to select the data, another one to create the plot and then add the points to it.\n\nblockr has a its own __validation__ system. For instance, using the below example, you can try to press return on the first block select box (penguins is the selected default). You'll notice an immediate feedback message. A global message is displayed in the block upper middle part: \"1 error(s) found in this block\". You get more detailed mesages next to the faulty input(s): \"selected value(s) not among provided choices\". You can repeat the same experience with the last plot layer block, by emptying the color and shape select inputs. Error messages can accumulate.\n\nYou can dynamically add blocks to a current __stack__, that gathers a set of related blocks. You can think a stack as a data analysis __recipe__ as in cooking, where blocks are instructions. To add a new block, you can click on the `+` icon on the stack top right corner. This opens a sidebar on the left side, where one may search for blocks that are compatible with the current state of the pipeline. With an empty stack, only entry point blocks are suggested, so you can import data. Then, after clicking on the block, the suggestion list changes so you can, for instance, filter data or select only a subset of columns, and much more.\n\n```{shinylive-r}\n#| standalone: true\n#| components: [viewer]\n#| column: screen-inset-shaded\n#| viewerHeight: 800\nwebr::install(\"blockr\", repos = \"https://bristolmyerssquibb.github.io/webr-repos/\")\n\nlibrary(blockr)\nlibrary(palmerpenguins)\nlibrary(ggplot2)\n\nnew_ggplot_block <- function(col_x = character(), col_y = character(), ...) {\n\n  data_cols <- function(data) colnames(data)\n\n  new_block(\n    fields = list(\n      x = new_select_field(col_x, data_cols, type = \"name\"),\n      y = new_select_field(col_y, data_cols, type = \"name\")\n    ),\n    expr = quote(\n      ggplot(mapping = aes(x = .(x), y = .(y)))\n    ),\n    class = c(\"ggplot_block\", \"plot_block\"),\n    ...\n  )\n}\n\nnew_geompoint_block <- function(color = character(), shape = character(), ...) {\n\n  data_cols <- function(data) colnames(data$data)\n\n  new_block(\n    fields = list(\n      color = new_select_field(color, data_cols, type = \"name\"),\n      shape = new_select_field(shape, data_cols, type = \"name\")\n    ),\n    expr = quote(\n      geom_point(aes(color = .(color), shape = .(shape)), size = 2)\n    ),\n    class = c(\"geompoint_block\", \"plot_layer_block\", \"plot_block\"),\n    ...\n  )\n}\n\nstack <- new_stack(\n  data_block = new_dataset_block(\"penguins\", \"palmerpenguins\"),\n  plot_block = new_ggplot_block(\"flipper_length_mm\", \"body_mass_g\"),\n  layer_block = new_geompoint_block(\"species\", \"species\")\n)\nserve_stack(stack)\n```\n\nTBD: add workspace example to connect stacks\n\nAs an end-user, you are not supposed to write code. As such, if you think anything is missing, you can open an issue [here](https://github.com/BristolMyersSquibb/blockr/issues), or ask any developer you are working with to create new blocks. This leads us to the second part of this blog post ... How to use blockr as a developers?\n\n### As a developer\n\nHow to install it:\n\n```r\npak::pak(\"BristolMyersSquibb/blockr\")\n```\n\nblockr can't provide any single data manipulation or visualization block. That's the reason why we made it easily __extensible__. You can get an introduction to blockr for developers [here](https://bristolmyerssquibb.github.io/blockr/articles/blockr.html#blockr-for-developers).\n\nIn the following, we create an ordinary differential equations solver block using the pracma package. We choose the Lorenz [attractor](https://en.wikipedia.org/wiki/Lorenz_system). With R, equations may be written as:\n\n```r\nlorenz <- function(t, y, parms) {\n  c(\n    X = parms[1] * y[1] + y[2] * y[3],\n    Y = parms[2] * (y[2] - y[3]),\n    Z = -y[1] * y[2] + parms[3] * y[2] - y[3]\n  )\n}\n```\n\nwhere `t` is the time, `y` a vector of solutions and `params` the various parameters. If you are familiar with [deSolve](https://cran.r-project.org/web/packages/deSolve/index.html), equations are defined with similar functions. For this blog post, we selected pracma as deSolve does not run in shinylive, so you could not see the embedded demonstration.\n\n### Add interactivity with the __fields__\n\nWe want to add interactivity on the 3 different parameters. Hence, we create our new block function with 3 __fields__ inside a list. Since the expected values are numbers, we leverage the `new_numeric_field`. Parameters are only explicitly shown for the first field:\n\n```r\nnew_ode_block <- function(...) {\n  fields <- list(\n    a = new_numeric_field(value = -8 / 3, min = -10, max = 20),\n    b = new_numeric_field(-10, -50, 100),\n    c = new_numeric_field(28, 1, 100)\n  )\n  # TBD\n  # ...\n}\n```\n\nAs you may imagine, these fields are subsequently translated into shiny inputs, that is `numericInput` in our example. If you face a situation where you need to implement a custom field, not included in blockr, you can read this [vignette](https://bristolmyerssquibb.github.io/blockr/articles/new-field.html).\n\n\n### Create the block expression\nAs next step, we __instantiate__ our block with the `new_block` blockr __constructor__:\n\n```r\nnew_block(\n  fields = fields,\n  expr = quote(<EXPR>),\n  ...,\n  class = <CLASSES>,\n  submit = FALSE\n)\n```\n\nA block is composed of fields, a quoted __expression__ which involved fields (to delay the evaluation), somes __classes__ which control the block behavior, and extra parameters passed with `...`. Finally, `submit` allows to delay the block evaluation by requiring the user to click on a submit button (FALSE by default). This prevents from triggering unwanted intensive computations.\n\nIn our example, the expression calls the `ode45` function. Notice the usage of `substitute` to inject the `lorenz` function within the expression. This is necessary since `lorenz` is defined outside of the expression, and using `quote` would fail. Fields are invoked with `.(field_name)`, a rather strange notation, required by `bquote` to process the expression. It is not mandory to understand this technical underlying detail, but this standard must be respected. You may also notice that some parameters like the initial conditions `y0` or time values are hardcoded. We leave the reader to transform them into fields, as an exercise:\n\n```r\nnew_block(\n  fields = fields,\n  expr = substitute(\n    as.data.frame(\n      ode45(\n        fun,\n        y0 = c(X = 1, Y = 1, Z = 1),\n        t0 = 0,\n        tfinal = 100,\n        parms = c(.(a), .(b), .(c))\n      )\n    ),\n    list(fun = lorenz)\n  )\n  # TBD\n)\n```\n\n### Add the right classes\n\nWe give our block 2 classes, namely `ode_block` and `data_block`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_ode_block <- function(...) {\n  fields <- list(\n    a = new_numeric_field(-8 / 3, -10, 20),\n    b = new_numeric_field(-10, -50, 100),\n    c = new_numeric_field(28, 1, 100)\n  )\n\n  new_block(\n    fields = fields,\n    expr = substitute(\n      as.data.frame(\n        ode45(\n          fun,\n          y0 = c(X = 1, Y = 1, Z = 1),\n          t0 = 0,\n          tfinal = 100,\n          parms = c(.(a), .(b), .(c))\n        )\n      ),\n      list(fun = lorenz)\n    ),\n    ...,\n    class = c(\"ode_block\", \"data_block\")\n  )\n}\n```\n:::\n\n\n\nAs explained earlier, they are required to control the block behavior, as blockr is build with [S3](https://adv-r.hadley.nz/s3.html). For instance, `data_block` have a specific __evaluation__ method, to calculate the expression:\n\n```r\nevaluate_block.data_block <- function (x, ...) \n{\n  stopifnot(...length() == 0L)\n  eval(generate_code(x), new.env())\n}\n```\n\nwhere `generate_code` processes the block code. __Data__ blocks are considered as entry point blocks, as opposed to __transformation__ blocks, that operate on data. Therefore, you may easily understand that the evaluation method for a transform block requires to pass the data from the previous block with `%>%`:\n\n```r\nevaluate_block.block <- function (x, data, ...) \n{\n  stopifnot(...length() == 0L)\n  eval(substitute(data %>% expr, list(expr = generate_code(x))), list(data = data))\n}\n```\n\nIf you want to build a plot block and plot layers blocks, you would have to design a specific evaluate method, that accounts for the `+` operator required by ggplot2. To learn more about how to create a plot block, you can read this [article](https://bristolmyerssquibb.github.io/blockr/articles/plot-block.html).\n\n### Demo\n\n```{shinylive-r}\n#| standalone: true\n#| components: [viewer, editor]\n#| column: screen-inset-shaded\n#| viewerHeight: 800\nwebr::install(\"blockr\", repos = c(\"https://bristolmyerssquibb.github.io/webr-repos\", \"https://repo.r-wasm.org\"))\nwebr::install(\"blockr.ggplot2\", repos = c(\"https://bristolmyerssquibb.github.io/webr-repos\", \"https://repo.r-wasm.org\"))\n\nlibrary(blockr)\nlibrary(pracma)\nlibrary(blockr.ggplot2)\n\nlorenz <- function(t, y, parms) {\n  c(\n    X = parms[1] * y[1] + y[2] * y[3],\n    Y = parms[2] * (y[2] - y[3]),\n    Z = -y[1] * y[2] + parms[3] * y[2] - y[3]\n  )\n}\n\nnew_ode_block <- function(...) {\n  fields <- list(\n    a = new_numeric_field(-8 / 3, -10, 20),\n    b = new_numeric_field(-10, -50, 100),\n    c = new_numeric_field(28, 1, 100)\n  )\n\n  new_block(\n    fields = fields,\n    expr = substitute(\n      as.data.frame(\n        ode45(\n          fun,\n          y0 = c(X = 1, Y = 1, Z = 1),\n          t0 = 0,\n          tfinal = 100,\n          parms = c(.(a), .(b), .(c))\n        )\n      ),\n      list(fun = lorenz)\n    ),\n    ...,\n    class = c(\"ode_block\", \"data_block\")\n  )\n}\n\nstack <- new_stack(\n  new_ode_block,\n  new_ggplot_block(\n    func = c(\"x\", \"y\"),\n    default_columns = c(\"y.1\", \"y.2\")\n  ),\n  new_geompoint_block\n)\nserve_stack(stack)\n```\n\n### Packaging new blocks: the registry\n\nIn the above example, we define the block on the fly. However, an other outstanding feature of blockr is the __registry__, which you can see as a blocks __supermarket__. From the R side, the registry is an __environment__ that can be extended by developers who bring their own blocks packages:\n\n\n\n```{mermaid}\n%%| mermaid-format: svg\n%%| mermaid-theme: default\nflowchart LR\n  subgraph blockr_custom[your_block_package]\n    new_block1[New block 1]\n    new_block2[New block 2]\n  end\n  blockr_custom--> |register| registry\n  subgraph registry[Registry]\n    subgraph select_reg[Select block]\n      reg_name[Name: select block]\n      reg_descr[Description: select columns in a table]\n      reg_classes[Classes: select_block, tranform_block]\n      reg_input[Input: data.frame]\n      reg_output[Output: data.frame]\n      reg_package[Package: blockr]\n    end\n    subgraph filter_reg[Filter block]\n    end\n    filter_reg --x |unregister| trash['fa:fa-trash']\n  end\n```\n\n\n\nTo get an overview of all available blocks within the blockr core package, we call `get_registry`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_registry()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                 ctor                                  description  category\n1       arrange_block                              Arrange columns transform\n2           csv_block                           Read a csv dataset    parser\n3       dataset_block              Choose a dataset from a package      data\n4  filesbrowser_block       Select files on the server file system      data\n5        filter_block                       filter rows in a table transform\n6      group_by_block                             Group by columns transform\n7          head_block               Select n first rows of dataset transform\n8          join_block                              Join 2 datasets transform\n9          json_block                          Read a json dataset    parser\n10       mutate_block                                 Mutate block transform\n11          rds_block                           Read a rds dataset    parser\n12       result_block Shows result of another stack as data source      data\n13       select_block                    select columns in a table transform\n14    summarize_block                        summarize data groups transform\n15       upload_block                   Upload files from location      data\n16          xpt_block                           Read a xpt dataset    parser\n                                            classes      input     output\n1             arrange_block, transform_block, block data.frame data.frame\n2   csv_block, parser_block, transform_block, block     string data.frame\n3                  dataset_block, data_block, block       <NA> data.frame\n4             filesbrowser_block, data_block, block       <NA>     string\n5              filter_block, transform_block, block data.frame data.frame\n6            group_by_block, transform_block, block data.frame data.frame\n7                head_block, transform_block, block data.frame data.frame\n8                join_block, transform_block, block data.frame data.frame\n9  json_block, parser_block, transform_block, block     string data.frame\n10             mutate_block, transform_block, block data.frame data.frame\n11  rds_block, parser_block, transform_block, block     string data.frame\n12                  result_block, data_block, block       <NA> data.frame\n13             select_block, transform_block, block data.frame data.frame\n14          summarize_block, transform_block, block data.frame data.frame\n15                  upload_block, data_block, block       <NA>     string\n16  xpt_block, parser_block, transform_block, block     string data.frame\n   package\n1   blockr\n2   blockr\n3   blockr\n4   blockr\n5   blockr\n6   blockr\n7   blockr\n8   blockr\n9   blockr\n10  blockr\n11  blockr\n12  blockr\n13  blockr\n14  blockr\n15  blockr\n16  blockr\n```\n\n\n:::\n:::\n\n\n\nThis function returns a dataframe containing information about blocks such as their constructors, like `new_ode_block`, the description, the category (data, transform, plot ... this is user defined), classes, accepted input, returned output and package.\n\nTo register a block we call `register_block` (or `register_blocks` for multiple blocks):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nregister_my_blocks <- function() {\n  register_block(\n    constructor = new_ode_block,\n    name = \"ode block\",\n    description = \"Computed the Lorent attractor solutions\",\n    classes = c(\"ode_block\", \"data_block\"),\n    input = NA_character_,\n    output = \"data.frame\",\n    package = \"<YOUR_PACKAGE>\",\n    category = \"data\"\n  )\n  # You can register any other blocks here ...\n}\n```\n:::\n\n\n\nwhere `<YOUR_PACKAGE>` must be replaced by your real package name.\n\nWithin a `zzz.R` script, you can ensure to register any block when the package loads with a __hook__:\n\n```r\n.onLoad <- function(libname, pkgname) {\n  register_my_blocks()\n  invisible(NULL)\n}\n```\n\nAfter the registration, you can check whether the registry is updated, by looking at the ode block:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nregister_my_blocks()\nreg <- get_registry()\nreg[reg$package == \"<YOUR_PACKAGE>\", ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        ctor                             description category\n11 ode_block Computed the Lorent attractor solutions     data\n                        classes input     output        package\n11 ode_block, data_block, block  <NA> data.frame <YOUR_PACKAGE>\n```\n\n\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}